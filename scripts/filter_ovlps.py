import sys
import os

__author__ = "Xiao Luo"

usage = '''
This program is used to filter long read overlaps(i.e.,duplicate or internal overlaps)
which are generated by minimap2
'''


def paf_to_str(paf, min_len, min_identity, cigar=False):
    '''
    read paf file into a string, only keep 12 columns to reduce memory
    '''
    if os.path.getsize(paf) == 0:
        return ''
    ovlp_str = ''
    with open(paf, 'r') as fr:
        for line in fr:
            a = line.split()
            if int(a[10]) >= min_len and float(a[9]) / float(a[10]) >= min_identity:
                if cigar:
                    ovlp_str += line  # keep all infor, like CIGAR
                else:
                    ovlp_str += '\t'.join(line.split()[:12]) + '\n'
    return ovlp_str.strip()


def rm_dupovlp(ovlp_str):
    '''
    only keep the longest overlap if multiple overlaps exist for one pair reads
    and remove self-overlaps
    '''
    ovlp = {}
    self_counts = 0
    dup_counts = 0
    for line in ovlp_str.strip().split('\n'):
        a = line.strip().split()
        qname = a[0]
        tname = a[5]
        if qname == tname:
            self_counts += 1
            continue
        ovlp_len = int(a[10])
        key = ':'.join(sorted([qname, tname]))
        if key not in ovlp:
            ovlp[key] = line
        elif ovlp_len > int(ovlp[key].split()[10]):
            ovlp[key] = line
            dup_counts += 1

    ovlp_str2 = '\n'.join([ovlp[key] for key in ovlp.keys()])
    print("self-overlap counts:" + str(self_counts))
    print("duplicated overlap counts:" + str(dup_counts))
    ovlp = {}
    return ovlp_str2


def keep_max_ovlps(ovlp_str, max_ovlps, rm_extra_ovlps=False):
    '''
    only keep the top max_ovlps(with decrease order of overlap length) overlaps for each read,
    in the final result there may be some reads that have more than max_ovlps in all, which is reasonable
    rm_extra_ovlps: is equal to delete edges which are out of max number overlaps in the overlap graph
    '''
    out = []
    rr2line = {}
    used_rr = {}
    if not rm_extra_ovlps:
        for line in ovlp_str.strip().split('\n'):
            a = line.strip().split()
            qname = a[0]
            tname = a[5]
            rr2line.setdefault(qname, {})[tname] = line
            rr2line.setdefault(tname, {})[qname] = line
            used_rr.setdefault(qname, {})[tname] = 0
            used_rr.setdefault(tname, {})[qname] = 0
        reads = list(rr2line.keys())
        for read in reads:
            if read not in rr2line: continue
            if len(rr2line[read]) <= max_ovlps:
                ovlp_reads = list(rr2line[read].keys())
            else:
                all_ovlp_reads = [t[0] for t in
                                  sorted(rr2line[read].items(), key=lambda d: int(d[1].split()[10]), reverse=True)]
                ovlp_reads = all_ovlp_reads[:max_ovlps]

            for ovlp_read in ovlp_reads:
                if not used_rr[read][ovlp_read]:
                    out.append(rr2line[read][ovlp_read])
                    used_rr[read][ovlp_read] = 1
                    used_rr[ovlp_read][read] = 1
                    # del rr2line[ovlp_read][read]
            # del rr2line[read]
    else:  # TODO still a bug?
        for line in ovlp_str.strip().split('\n'):
            a = line.strip().split()
            qname = a[0]
            tname = a[5]
            rr2line.setdefault(qname, {})[tname] = line
            rr2line.setdefault(tname, {})[qname] = line
        reads = list(rr2line.keys())
        for read in reads:
            if read not in rr2line: continue
            if len(rr2line[read]) <= max_ovlps:
                ovlp_reads = list(rr2line[read].keys())
            else:
                all_ovlp_reads = [t[0] for t in
                                  sorted(rr2line[read].items(), key=lambda d: int(d[1].split()[10]), reverse=True)]
                ovlp_reads = all_ovlp_reads[:max_ovlps]
                for r in all_ovlp_reads[max_ovlps:]:
                    if r in rr2line:
                        del rr2line[r][read]
                # print('{} overlapped reads number:{}'.format(read,len(ovlp_reads)))

            for ovlp_read in ovlp_reads:
                out.append(rr2line[read][ovlp_read])
                del rr2line[ovlp_read][read]
            del rr2line[read]

    ovlp_str2 = '\n'.join(out)

    # delet large variables
    del rr2line, used_rr, out

    return ovlp_str2


def rm_intermatch(ovlp_str, o=1000, r=0.8):
    '''
    filter internal match overlaps
    o: overhang length
    r: ratio
    '''
    ovlps = []
    inter = 0
    for line in ovlp_str.strip().split('\n'):
        a = line.strip().split()
        l1 = int(a[1])
        b1 = int(a[2])
        e1 = int(a[3])
        direction = a[4]
        l2 = int(a[6])
        if direction == '-':
            '''
            - overhang region: ***
            - b2,e2: both are the cordinates in the following sequence,
              no matter what the direction is.

                       b1        e1    l1
            v ------------------------->
                   |***|/////////|*****|
                w  <----------------------------
                       b2        e2            l2
            '''
            b2 = l2 - int(a[8])  # end in original seq
            e2 = l2 - int(a[7])  # start in original seq
        else:
            b2 = int(a[7])
            e2 = int(a[8])

        # from algorithm 5 in minimap paper
        overhang = min(b1, b2) + min(l1 - e1, l2 - e2)
        maplen = max(e1 - b1, e2 - b2)

        if overhang > min(o, maplen * r):
            # internal match
            inter += 1
            continue
        else:
            ovlps.append(line)
    ovlp_str2 = '\n'.join(ovlps)
    print("internal overlap counts:" + str(inter))
    del ovlps
    return ovlp_str2


def ovlp_str2paf(ovlp_str, paf):
    with open(paf, 'w') as fw:
        fw.write(ovlp_str)

def rm_extra_ovlps(in_paf,out_paf,max_ovlps, rm_extra_ovlps):
    if os.path.getsize(in_paf)==0:
        open(out_paf,'w').close()
        return out_paf
    ovlp_str = paf_to_str(in_paf, 0, 0)
    print('keeping the max number of overlaps...')
    ovlp_str = keep_max_ovlps(ovlp_str, max_ovlps, rm_extra_ovlps)
    ovlp_str2paf(ovlp_str, out_paf)
    return out_paf

def filter_ovlp(in_paf, out_paf, min_ovlp_len=1000, min_identity=0.9, o=800, r=0.8, max_ovlps=None,
                rm_extra_ovlps=False, cigar=False):
    ovlp_str = paf_to_str(in_paf, min_ovlp_len, min_identity, cigar)  # filter wrong overlaps

    if ovlp_str:
        print('removing internal overlaps...')
        ovlp_str = rm_intermatch(ovlp_str, o, r)
    if ovlp_str:
        print('removing duplicated overlaps...')
        ovlp_str = rm_dupovlp(ovlp_str)

    if max_ovlps and ovlp_str:
        print('keeping the max number of overlaps...')
        ovlp_str = keep_max_ovlps(ovlp_str, max_ovlps, rm_extra_ovlps)

    if not ovlp_str:
        print('No overlap any more. Stop iterating')

    print('writing the filtered overlaps into paf file...')
    ovlp_str2paf(ovlp_str, out_paf)
    return


def main():
    # in_paf = "../data/local/xx.paf"  # ovlpf or paf file
    # out_paf="../data/local/xx.filtered.paf"
    in_paf, out_paf, min_ovlp_len, min_identity, o = sys.argv[1:]
    filter_ovlp(in_paf, out_paf, int(min_ovlp_len), float(min_identity), int(o))
    return


if __name__ == '__main__':
    sys.exit(main())
